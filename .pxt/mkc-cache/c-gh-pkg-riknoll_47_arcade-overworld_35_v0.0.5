{"files":{"pxt.json":"{\n    \"name\": \"arcade-overworld\",\n    \"version\": \"0.0.5\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"arcade-extension-utils\": \"github:riknoll/arcade-extension-utils#v0.0.1\"\n    },\n    \"files\": [\n        \"docs/create-map.md\",\n        \"docs/current-location.md\",\n        \"docs/get-map-at.md\",\n        \"docs/get-map-in-direction.md\",\n        \"docs/load-map-in-direction.md\",\n        \"docs/load-map.md\",\n        \"docs/map-exists-at.md\",\n        \"docs/map-exists-in-direction.md\",\n        \"docs/on-map-loaded.md\",\n        \"docs/set-animation-duration.md\",\n        \"docs/set-animation-fade-color.md\",\n        \"docs/set-animation-timing-function.md\",\n        \"docs/set-animation-type.md\",\n        \"docs/set-continuous-mode-enabled.md\",\n        \"docs/set-map-transition-radius.md\",\n        \"docs/set-map-transitions-enabled.md\",\n        \"docs/set-overworld.md\",\n        \"docs/set-player-sprite.md\",\n        \"docs/set-scroll-animation-z-index.md\",\n        \"docs/set-walls-block-transitions.md\",\n        \"main.ts\",\n        \"state.ts\",\n        \"continuousTilemap.ts\",\n        \"api.ts\",\n        \"README.md\"\n    ],\n    \"testFiles\": [\n        \"test.tilemap.jres\",\n        \"test.tilemap.ts\",\n        \"test.ts\"\n    ],\n    \"targetVersions\": {},\n    \"supportedTargets\": [\n        \"arcade\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","docs/create-map.md":"# create map\n\nThese blocks are used to create the grid for the overworld extension. The tilemaps with the number 16 next to them use 16x16 tiles, and the tilemaps with the number 8 use 8x8 tiles.\n\nWhen creating the overworld grid, you can also use the normal tilemap blocks from the Scene category or the arcade-tile-util extension. Simply create a double array filled with tilemaps!\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/current-location.md":"# current location\n\nLets you get the column and row of the currently loaded tilemap in the overworld grid.\n\n```sig\noverworld.currentLocation(overworld.LocationProperty.Column)\n```\n\n## Parameters\n\n* **property**: The property to get from the current location\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/get-map-at.md":"# get map at\n\nReturns the tilemap at the given location in the overworld grid. If there is no map at that location in the grid, this function will return undefined\n\n```sig\noverworld.getMapAt(0, 0)\n```\n\n## Parameters\n\n* **overworldColumn**: The column of the map to get in the overworld grid\n* **overworldRow**: The row of the map to get in the overworld grid\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/get-map-in-direction.md":"# get map in direction\n\nReturns the tilemap adjacent to the current tilemap in the given direction. If there is no map in the given direction, this function will return undefined\n\n```sig\noverworld.getMapInDirection(CollisionDirection.Left)\n```\n\n## Parameters\n\n* **direction**: The direction to get the tilemap from\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/load-map-in-direction.md":"# load map in direction\n\nLoads the tilemap adjacent to the current tilemap in the given direction. If there is no map in the given direction, nothing will happen.\n\n```sig\noverworld.loadMapInDirection(CollisionDirection.Left)\n```\n\nThis block does nothing in \"continuous mode\".\n\n## Parameters\n\n* **direction**: The direction to load the tilemap from\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/load-map.md":"# load map\n\nLoads the tilemap at the given column and row in the overworld grid. If there is no map at the given location, nothing will happen.\n\n```sig\noverworld.loadMap(0, 0)\n```\n\nThis block does nothing in \"continuous mode\".\n\n## Parameters\n\n* **overworldColumn**: The column to load in the overworld grid\n* **overworldRow**: The row to load in the overworld grid\n\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/map-exists-at.md":"# map exists at\n\nUsed to check if there is a map in the overworld at the given overworld coordinates.\n\n```sig\noverworld.mapExistsAt(0, 0)\n```\n\n## Parameters\n\n* **overworldColumn**: The column to check in the overworld grid\n* **overworldRow**: The row to check in the overworld grid\n\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/map-exists-in-direction.md":"# map exists in direction\n\nUsed to check if there is a map in the given direction from the currently loaded location in the overworld. In other words, if this function returns false, it means that the player has reached the edge of the overworld and can't move further in that direction.\n\n```sig\noverworld.mapExistsInDirection(CollisionDirection.Left)\n```\n\n## Parameters\n\n* **direction**: The direction to check for a tilemap in\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/on-map-loaded.md":"# on map loaded\n\nRuns some code whenever a new map is loaded by the overworld extension. This is great for doing things like spawning sprites and destroying sprites from the previous tilemap.\n\n```sig\noverworld.onMapLoaded(function (overworldColumn, overworldRow, map) {\n\t\n})\n```\n\nIn \"continuous mode\", this block will still fire whenever the player sprite enters a new tilemap in the grid. This is great for doing things like lazily loading sprites when the player gets close.\n\n## Parameters\n\n* **overworldColumn**: The column in the overworld grid where the loaded tilemap is located\n* **overworldRow**: The row in the overworld grid where the loaded tilemap is located\n* **map**: The tilemap that was loaded\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-animation-duration.md":"# set animation duration\n\nSets the duration of the tilemap transition animation in milliseconds. This block only works if you have set an animation type other than \"none\" using the `set animation type` function.\n\n```sig\noverworld.setAnimationDuration(500)\n```\n\nThis block does nothing if you are using \"continuous mode\".\n\n## Parameters\n\n* **duration**: The duration of the animation in milliseconds\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-animation-fade-color.md":"# set animation fade color\n\nSets the color to fade the screen to when using the \"fade to custom color\" animation type. This block only has an effect when the animation type is set to \"fade to custom color\".\n\nThe color should be written in hex code format. For example, #000000 is black, #ffffff is white, and #ff0000 is bright red!\n\n```sig\noverworld.setAnimationFadeColor(\"#000000\")\n```\n\nThis block does nothing if you are using \"continuous mode\".\n\n## Parameters\n\n* **color**: The color to use in hex code format\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-animation-timing-function.md":"# set animation timing function\n\nSets the timing function, which controls how the tilemap transition animation progresses once it has started. The default timing function is linear; try changing it to something else and seeing what effect it has! This block only takes effect if you have enabled animations using the \"set animation type\" function.\n\n```sig\noverworld.setAnimationTimingFunction(overworld.TimingFunction.Linear)\n```\n\nThis block does nothing if you are using \"continuous mode\".\n\n## Parameters\n\n* **timing function**: The timing function to use with the animation\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-animation-type.md":"# set animation type\n\nSets the type of animation to be used when transitioning between tilemaps in the overworld grid. For more details on animations and examples of what they look like, read [this](https://github.com/riknoll/arcade-overworld?tab=readme-ov-file#animating-tilemap-transitions).\n\n```sig\noverworld.setAnimationType(overworld.AnimationType.None)\n```\n\nThis block does nothing if you are using \"continuous mode\".\n\n## Parameters\n\n* **type**: The type of animation to use when transitioning between tilemaps or \"none\" to not use any transitions\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-continuous-mode-enabled.md":"# set continuous mode enabled\n\nEnables \"continuous mode\" when set to true. In continuous mode, all of the tilemaps in the overworld grid are combined into one giant tilemap. This setting is **off** by default.\n\n>Note: to use continuous mode, all tilemaps in the overworld need to have the exact same width and height! They also need to use the same tile size; no mixing 16x16 and 8x8 tiles!\n\n```sig\noverworld.setContinuousModeEnabled(false)\n```\n\nContinuous mode can be useful if you want to make tilemaps that are larger than the maximum tilemap dimensions. You can also use this to bypass the limit of 255 tiles per tilemap, but that might cause some bugs so I wouldn't recommend it!\n\nYou might also use continuous mode if you want to reuse tilemaps inside of a bigger map. For example, if you were procedurally generating a dungeon you might want to use the same map for all of your hallways between rooms.\n\nWhen using continuous mode, the animation and transition blocks are disabled since there is no switching between tilemaps. However, you can still use the \"on map loaded\" event to figure out when the player moves between tilemaps. Likewise, the \"overworld location\" block will still return the column/row of the current sprite in the overworld grid.\n\n## Parameters\n\n* **enabled**: True to enable continuous mode or false to disable it.\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-map-transition-radius.md":"# set map transitions radius\n\nSets the distance that the player sprite needs to be from the edge of a tilemap before a tilemap transition happens. By default, the radius is 4 pixels which means that the maps won't change until the player is 4 pixels or less from the edge of the map.\n\nThis radius only triggers if the player is moving towards the edge of the map. In other words, even if the player were placed all the way on the left edge of a tilemap, they would not trigger the transition to the tilemap in the left direction unless they actually have a negative x velocity (i.e. they are moving leftwards).\n\n```sig\noverworld.setMapTransitionRadius(4)\n```\n\n## Parameters\n\n* **radius**: The distance from the edges of the map where the player sprite should start triggering map transitions\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-map-transitions-enabled.md":"# set map transitions enabled\n\nThis block allows you to temporarily disable the map transitioning behavior of the overworld extension. You can think of passing false to this function as turning overworld \"off\".\n\nIt's useful if you want to temporarily load a tilemap outside the tilemap grid (e.g. going inside a building like a shop). You can also use it to temporarily trap the player in the current room until they figure out a puzzle.\n\n```sig\noverworld.setMapTransitionsEnabled(false)\n```\n\n## Parameters\n\n* **enabled**: True to enable map transitions, false to disable them\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-overworld.md":"# set overworld\n\nSets the current overworld. An overworld is a grid of tilemaps that the player sprite will move between when they approach the edge of the current map. Using this function will not cause the overworld to immediately take effect; make sure you use `load map` to load a tilemap from the grid!\n\n```sig\noverworld.setOverworld([])\n```\n\nThe argument to this function is a double array of tilemaps. Each array inside the outer array represents one row of columns for the map.\n\n## Parameters\n\n* **map**: A double array of tilemaps\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-player-sprite.md":"# set player sprite\n\nSets the current player sprite. The player sprite is what controls when arcade-overworld moves between tilemaps. When the player sprite approaches the edge of the current tilemap, it will cause the next tilemap in that direction to load. For a more detailed explanation, read [this](https://github.com/riknoll/arcade-overworld?tab=readme-ov-file#transitioning-between-maps).\n\nIf you need to temporarily disable map transitions, you can use the `set map transitions enabled` block.\n\n```sig\noverworld.setPlayerSprite(null)\n```\n\narcade-overworld is designed for single player games. If you want to use it with a multiplayer game, you'll either need to make one player the player sprite or use the `load map` and `load map in direction` blocks yourself to control the map transitions.\n\n## Parameters\n\n* **sprite**: The player sprite\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-scroll-animation-z-index.md":"# set scroll animation z index\n\nSets the z-index at which the scroll animation renders. Any sprites with a higher z-index will be ignored by the scroll. This block only has an effect if the animation is set to scroll. The default value for this is 99, which is one less than the z-index that the HUD from the info category renders at (100).\n\n```sig\noverworld.setScrollAnimationZIndex(99)\n```\n\nThis block does nothing if you are using \"continuous mode\".\n\n## Parameters\n\n* **z**: The z depth to render the animation at\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","docs/set-walls-block-transitions.md":"# set walls block transitions\n\nThis controls whether the walls in a destination tilemap will stop the player from moving into that map. By default, this setting is **off**.\n\nIf set to on, the player sprite will only move between maps if the location they would be placed in the destination map has room for the sprite to fit without overlapping any walls. For a more detailed explanation, read [this](https://github.com/riknoll/arcade-overworld?tab=readme-ov-file#transitioning-between-maps).\n\n```sig\noverworld.setWallsBlockTransitions(false)\n```\n\n## Parameters\n\n* **enabled**: True to enable this setting. False to disable it\n\n## Example #example\n\n```blocks\n```\n\n```package\narcade-overworld=github:riknoll/arcade-overworld\n```","main.ts":"","state.ts":"namespace overworld {\n    class State {\n        protected map: tiles.TileMapData[][];\n        protected transitionRadius: number;\n        protected playerSprite: Sprite;\n        protected transitionsEnabled: boolean;\n        protected column: number;\n        protected row: number;\n        protected enabled: boolean;\n        protected wallsBlockTransitions: boolean;\n        protected continuousMode: boolean;\n        protected continuousData: overworld.TileMapData;\n        protected mapLoadedHandlers: ((col: number, row: number, map: tiles.TileMapData) => void)[]\n\n        transitionDuration: number;\n        transitionFunc: TimingFunction;\n        transitionType: AnimationType;\n\n        protected customColor: number;\n        protected isTransitioning: boolean;\n        protected nextPlayerLeft: number;\n        protected nextPlayerTop: number;\n        protected scrollTransitionZIndex: number;\n\n        constructor() {\n            this.customColor = 0;\n            this.transitionRadius = 4;\n            this.column = 0;\n            this.row = 0;\n            this.wallsBlockTransitions = false;\n            this.transitionDuration = 300;\n            this.scrollTransitionZIndex = 99;\n            this.transitionFunc = TimingFunction.Linear;\n            this.transitionType = AnimationType.None;\n            this.mapLoadedHandlers = [];\n\n            game.eventContext().registerFrameHandler(scene.UPDATE_PRIORITY - 1, () => {\n                this.update();\n            })\n        }\n\n        setMap(map: tiles.TileMapData[][]) {\n            this.map = map;\n            if (this.continuousMode) {\n                this.initContinuousTilemap();\n            }\n            else if (this.enabled === undefined) {\n                this.enabled = !!map;\n            }\n        }\n\n        setPlayerSprite(sprite: Sprite) {\n            this.playerSprite = sprite;\n        }\n\n        loadMap(column: number, row: number, transitionDirection?: CollisionDirection): boolean {\n            if (this.continuousMode) {\n                this.setContinuousModeEnabled(false);\n            }\n\n            const newMap = this.getMap(column, row);\n            if (!newMap) return false;\n\n            const doTransition = () => {\n                this.column = column;\n                this.row = row;\n\n                let didTransition = false;\n                if (transitionDirection !== undefined) {\n                    if (this.transitionType === AnimationType.Scroll) {\n                        this.startScrollTransition(transitionDirection, newMap);\n                        didTransition = true;\n                    }\n                    else if (this.transitionType === AnimationType.FadeToWhite) {\n                        this.startColorTransition(newMap, 255, 255, 255);\n                        didTransition = true;\n                    }\n                    else if (this.transitionType === AnimationType.FadeToBlack) {\n                        this.startColorTransition(newMap, 0, 0, 0);\n                        didTransition = true;\n                    }\n                    else if (this.transitionType === AnimationType.FadeToColor) {\n                        this.startColorTransition(\n                            newMap,\n                            (this.customColor >> 16) & 0xff,\n                            (this.customColor >> 8) & 0xff,\n                            this.customColor & 0xff\n                        )\n                        didTransition = true;\n                    }\n                }\n\n                if (!didTransition) {\n                    tiles.setTilemap(newMap);\n                    if (this.playerSprite) {\n                        this.playerSprite.left = this.nextPlayerLeft;\n                        this.playerSprite.top = this.nextPlayerTop;\n                    }\n                    this.fireMapLoadEvent();\n                }\n            }\n\n            if (this.playerSprite) {\n                this.nextPlayerLeft = this.playerSprite.left;\n                this.nextPlayerTop = this.playerSprite.top;\n            }\n\n            if (transitionDirection === undefined || !this.playerSprite) {\n                doTransition();\n                return true;\n            }\n\n            const tileWidth = 1 << newMap.scale;\n\n            const playerWidth = Fx.toInt(this.playerSprite._hitbox.width);\n            const playerHeight = Fx.toInt(this.playerSprite._hitbox.height);\n            const mapWidth = newMap.width << newMap.scale;\n            const mapHeight = newMap.height << newMap.scale;\n            if (transitionDirection == CollisionDirection.Top) {\n                if (canSpriteFit(\n                    newMap,\n                    this.playerSprite.left,\n                    (newMap.height << newMap.scale) - playerHeight - 1,\n                    playerWidth,\n                    playerHeight\n                )) {\n                    this.nextPlayerTop = (newMap.height << newMap.scale) - playerHeight - 1;\n                    doTransition();\n                    return true;\n                }\n            }\n            else if (transitionDirection == CollisionDirection.Bottom) {\n                if (canSpriteFit(\n                    newMap,\n                    this.playerSprite.left,\n                    0,\n                    playerWidth,\n                    playerHeight\n                )) {\n                    this.nextPlayerTop = 0;\n                    doTransition();\n                    return true;\n                }\n            }\n            else if (transitionDirection == CollisionDirection.Left) {\n                if (canSpriteFit(\n                    newMap,\n                    (newMap.width << newMap.scale) - playerWidth - 1,\n                    this.playerSprite.top,\n                    playerWidth,\n                    playerHeight\n                )) {\n                    this.nextPlayerLeft = (newMap.width << newMap.scale) - playerWidth - 1;\n                    doTransition();\n                    return true;\n                }\n            }\n            else {\n                if (canSpriteFit(\n                    newMap,\n                    0,\n                    this.playerSprite.top,\n                    playerWidth,\n                    playerHeight\n                )) {\n                    this.nextPlayerLeft = 0;\n                    doTransition();\n                    return true;\n                }\n            }\n\n            if (this.wallsBlockTransitions) {\n                return false;\n            }\n\n\n            // when moving the player to the opposite edge of the next tilemap,\n            // try to find the closest tile that isn't obstructed by walls\n            if (transitionDirection == CollisionDirection.Top) {\n                for (let row = newMap.height - (playerHeight >> newMap.scale) - 1; row >= 0; row--) {\n                    let x0 = (this.playerSprite.left >> newMap.scale) << newMap.scale;\n                    let x1 = ((this.playerSprite.left >> newMap.scale) + 1) << newMap.scale;\n\n                    while (x0 >= 0 || x1 < mapWidth - playerWidth) {\n                        if (x0 >= 0) {\n                            if (canSpriteFit(\n                                newMap,\n                                x0,\n                                row << newMap.scale,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerLeft = x0;\n                                this.nextPlayerTop = ((row + 1) << newMap.scale) - playerHeight;\n                                doTransition();\n                                return true;\n                            }\n                            x0 -= tileWidth;\n                        }\n\n                        if (x1 < mapWidth - playerWidth) {\n                            if (canSpriteFit(\n                                newMap,\n                                x1,\n                                row << newMap.scale,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerLeft = x1;\n                                this.nextPlayerTop = ((row + 1) << newMap.scale) - playerHeight;\n                                doTransition();\n                                return true;\n                            }\n                            x1 += tileWidth;\n                        }\n                    }\n                }\n\n                this.nextPlayerTop = (newMap.height << newMap.scale) - playerHeight - 1;\n            }\n            else if (transitionDirection == CollisionDirection.Bottom) {\n                for (let row = 0; row < newMap.height - (playerHeight >> newMap.scale); row++) {\n                    let x0 = (this.playerSprite.left >> newMap.scale) << newMap.scale;\n                    let x1 = ((this.playerSprite.left >> newMap.scale) + 1) << newMap.scale;\n\n                    while (x0 >= 0 || x1 < mapWidth - playerWidth) {\n                        if (x0 >= 0) {\n                            if (canSpriteFit(\n                                newMap,\n                                x0,\n                                row << newMap.scale,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerLeft = x0;\n                                this.nextPlayerTop = row << newMap.scale;\n                                doTransition();\n                                return true;\n                            }\n                            x0 -= tileWidth;\n                        }\n\n                        if (x1 < mapWidth - playerWidth) {\n                            if (canSpriteFit(\n                                newMap,\n                                x1,\n                                row << newMap.scale,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerLeft = x1;\n                                this.nextPlayerTop = row << newMap.scale;\n                                doTransition();\n                                return true;\n                            }\n                            x1 += tileWidth;\n                        }\n                    }\n                }\n\n                this.nextPlayerTop = 0;\n            }\n            else if (transitionDirection == CollisionDirection.Left) {\n                for (let col = newMap.width - (playerWidth >> newMap.scale) - 1; col >= 0; col--) {\n                    let y0 = (this.playerSprite.top >> newMap.scale) << newMap.scale;\n                    let y1 = ((this.playerSprite.top >> newMap.scale) + 1) << newMap.scale;\n\n                    while (y0 >= 0 || y1 < mapHeight - playerHeight) {\n                        if (y0 >= 0) {\n                            if (canSpriteFit(\n                                newMap,\n                                col << newMap.scale,\n                                y0,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerTop = y0;\n                                this.nextPlayerLeft = ((col + 1) << newMap.scale) - playerWidth;\n                                doTransition();\n                                return true;\n                            }\n                            y0 -= tileWidth;\n                        }\n\n                        if (y1 < mapHeight - playerHeight) {\n                            if (canSpriteFit(\n                                newMap,\n                                col << newMap.scale,\n                                y1,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerTop = y1;\n                                this.nextPlayerLeft = ((col + 1) << newMap.scale) - playerWidth;\n                                doTransition();\n                                return true;\n                            }\n                            y1 += tileWidth;\n                        }\n                    }\n                }\n\n                this.nextPlayerLeft = (newMap.width << newMap.scale) - playerWidth - 1;\n            }\n            else {\n                for (let col = 0; col < newMap.width - (playerWidth >> newMap.scale) - 1; col++) {\n                    let y0 = (this.playerSprite.top >> newMap.scale) << newMap.scale;\n                    let y1 = ((this.playerSprite.top >> newMap.scale) + 1) << newMap.scale;\n\n                    while (y0 >= 0 || y1 < mapHeight - playerHeight) {\n                        if (y0 >= 0) {\n                            if (canSpriteFit(\n                                newMap,\n                                col << newMap.scale,\n                                y0,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerLeft = y0;\n                                this.nextPlayerTop = col << newMap.scale;\n                                doTransition();\n                                return true;\n                            }\n                            y0 -= tileWidth;\n                        }\n\n                        if (y1 < mapHeight - playerHeight) {\n                            if (canSpriteFit(\n                                newMap,\n                                col << newMap.scale,\n                                y1,\n                                playerWidth,\n                                playerHeight\n                            )) {\n                                this.nextPlayerTop = y1;\n                                this.nextPlayerLeft = col << newMap.scale;\n                                doTransition();\n                                return true;\n                            }\n                            y1 += tileWidth;\n                        }\n                    }\n                }\n\n                this.nextPlayerLeft = 0;\n            }\n\n            doTransition();\n            return true;\n        }\n\n        update() {\n            if (!this.playerSprite) return;\n\n            if (this.continuousMode) {\n                this.updateContinuousMode();\n            }\n            else {\n                this.updateMapTransitions();\n            }\n        }\n\n        protected updateContinuousMode() {\n            const column = this.playerSprite.x >> this.continuousData.scale;\n            const row = this.playerSprite.y >> this.continuousData.scale;\n\n            const overworldColumn = Math.idiv(column, this.continuousData.mapWidth);\n            const overworldRow = Math.idiv(row, this.continuousData.mapHeight);\n\n            if (\n                (this.column !== overworldColumn || this.row !== overworldRow) &&\n                this.getMap(overworldColumn, overworldRow)\n            ) {\n                this.column = overworldColumn;\n                this.row = overworldRow;\n                this.fireMapLoadEvent();\n            }\n        }\n\n        protected updateMapTransitions() {\n            if (!this.enabled || this.isTransitioning) return;\n\n            const map = this.getMap(this.column, this.row);\n\n            const mapWidth = map.width << map.scale;\n            const mapHeight = map.height << map.scale;\n\n            let movingLeft = this.playerSprite.vx < 0;\n            let movingRight = this.playerSprite.vx > 0;\n            let movingUp = this.playerSprite.vy < 0;\n            let movingDown = this.playerSprite.vy > 0;\n\n            // if the player is up against the edge of the tilemap, they\n            // won't have velocity in the direction of the edge even if the\n            // player is holding that directional button. so, we explicitly\n            // see if this player is being controlled by a player and see if\n            // the corresponding button is pressed\n            const controlledSprites = game.currentScene().controlledSprites;\n            for (let i = 0; i < controlledSprites.length; i++) {\n                if (!controlledSprites[i]) continue;\n\n                for (const sprite of controlledSprites[i]) {\n                    if (sprite.s !== this.playerSprite) continue;\n\n                    const ctrl = controller.players().find(c => c.playerIndex === i)\n\n                    if (!ctrl) continue;\n\n                    if (sprite.vx) {\n                        if (ctrl.right.isPressed() && !ctrl.left.isPressed()) {\n                            movingRight = movingRight || sprite.vx > 0;\n                            movingLeft = movingLeft || sprite.vx < 0;\n                        }\n                        else if (ctrl.left.isPressed() && !ctrl.right.isPressed()) {\n                            movingRight = movingRight || sprite.vx < 0;\n                            movingLeft = movingLeft || sprite.vx > 0;\n                        }\n                    }\n\n                    if (sprite.vy) {\n                        if (ctrl.down.isPressed() && !ctrl.up.isPressed()) {\n                            movingDown = movingDown || sprite.vy > 0;\n                            movingUp = movingUp || sprite.vy < 0;\n                        }\n                        else if (ctrl.up.isPressed() && !ctrl.down.isPressed()) {\n                            movingDown = movingDown || sprite.vy < 0;\n                            movingUp = movingUp || sprite.vy > 0;\n                        }\n                    }\n                }\n            }\n\n            if (movingUp && this.playerSprite.top < this.transitionRadius) {\n                if (this.loadMap(this.column, this.row - 1, CollisionDirection.Top)) {\n                    return;\n                }\n            }\n            if (movingRight && this.playerSprite.right > mapWidth - this.transitionRadius) {\n                if (this.loadMap(this.column + 1, this.row, CollisionDirection.Right)) {\n                    return;\n                }\n            }\n            if (movingDown && this.playerSprite.bottom > mapHeight - this.transitionRadius) {\n                if (this.loadMap(this.column, this.row + 1, CollisionDirection.Bottom)) {\n                    return;\n                }\n            }\n            if (movingLeft && this.playerSprite.left < this.transitionRadius) {\n                if (this.loadMap(this.column - 1, this.row, CollisionDirection.Left)) {\n                    return;\n                }\n            }\n        }\n\n        currentLocation(prop: LocationProperty) {\n            if (prop === LocationProperty.Column) {\n                return this.column;\n            }\n            return this.row;\n        }\n\n        getMap(column: number, row: number): tiles.TileMapData {\n            row |= 0;\n            column |= 0;\n\n            if (row < 0 || column < 0 || row >= this.map.length) {\n                return undefined;\n            }\n\n            const mapRow = this.map[row];\n\n            if (column >= mapRow.length) {\n                return undefined;\n            }\n\n            return mapRow[column];\n        }\n\n        setMapTransitionRadius(radius: number) {\n            this.transitionRadius = Math.max(radius, 1);\n        }\n\n        setMapTransitionsEnabled(enabled: boolean) {\n            this.enabled = enabled;\n        }\n\n        setWallsBlockTransitions(blockEnabled: boolean) {\n            this.wallsBlockTransitions = blockEnabled;\n        }\n\n        setFadeColor(color: string) {\n            this.customColor = parseColor(color);\n        }\n\n        setContinuousModeEnabled(enabled: boolean) {\n            if (!!this.continuousMode === !!enabled) return;\n\n            this.continuousMode = enabled;\n            this.continuousData = undefined;\n            if (enabled) {\n                this.initContinuousTilemap();\n            }\n            else {\n                const oldTilemap = game.currentScene().tileMap;\n                if (oldTilemap) {\n                    oldTilemap.renderable.destroy();\n                }\n                game.currentScene().tileMap = new tiles.TileMap();\n                this.column = 0;\n                this.row = 0;\n            }\n        }\n\n        addMapLoadedListener(handler: (column: number, row: number, map: tiles.TileMapData) => void) {\n            this.mapLoadedHandlers.push(handler);\n        }\n\n        removeMapLoadedListener(handler: (column: number, row: number, map: tiles.TileMapData) => void) {\n            this.mapLoadedHandlers = this.mapLoadedHandlers.filter(h => h !== handler);\n        }\n\n        setScrollAnimationZIndex(z: number) {\n            this.scrollTransitionZIndex = z;\n        }\n\n        protected initContinuousTilemap() {\n            if (!this.map) return;\n\n            const oldTilemap = game.currentScene().tileMap;\n            if (oldTilemap) {\n                oldTilemap.renderable.destroy();\n            }\n\n            const newTilemap = new overworld.TileMap();\n            game.currentScene().tileMap = newTilemap;\n            this.continuousData = new overworld.TileMapData(this.map);\n            tiles.setTilemap(this.continuousData);\n\n            let column: number;\n            let row: number;\n\n            if (this.playerSprite) {\n                column = this.playerSprite.x >> this.continuousData.scale;\n                row = this.playerSprite.y >> this.continuousData.scale;\n            }\n            else {\n                const camera = game.currentScene().camera;\n\n                column = camera.x >> this.continuousData.scale;\n                row = camera.y >> this.continuousData.scale;\n            }\n\n            this.column = Math.idiv(column, this.continuousData.mapWidth);\n            this.row = Math.idiv(row, this.continuousData.mapHeight);\n\n            if (!this.getMap(this.column, this.row)) {\n                this.column = 0;\n                this.row = 0;\n            }\n\n            this.fireMapLoadEvent();\n        }\n\n        protected startScrollTransition(direction: CollisionDirection, newMap: tiles.TileMapData) {\n            this.isTransitioning = true;\n            const playerIsInvisible = this.playerSprite.flags & SpriteFlag.Invisible;\n\n            const playerScreenLeft = this.playerSprite.left - game.currentScene().camera.drawOffsetX;\n            const playerScreenTop = this.playerSprite.top - game.currentScene().camera.drawOffsetY;\n\n            this.playerSprite.setFlag(SpriteFlag.Invisible, true);\n            const savedScreen = image.create(screen.width, screen.height);\n            const recorder = scene.createRenderable(this.scrollTransitionZIndex, (target, camera) => {\n                savedScreen.drawImage(screen, 0, 0);\n            });\n\n            game.currentScene().render();\n\n            recorder.destroy();\n\n            if (!playerIsInvisible) {\n                this.playerSprite.setFlag(SpriteFlag.Invisible, false);\n            }\n\n            let callback: control.FrameCallback;\n\n            const loadNewMap = () => {\n                if (!playerIsInvisible) {\n                    this.playerSprite.setFlag(SpriteFlag.Invisible, true);\n                }\n                this.playerSprite.left = this.nextPlayerLeft;\n                this.playerSprite.top = this.nextPlayerTop;\n\n                tiles.setTilemap(newMap);\n                this.fireMapLoadEvent();\n\n                game.eventContext().unregisterFrameHandler(callback);\n                const startTime = control.millis();\n                const renderer = scene.createRenderable(this.scrollTransitionZIndex, () => {\n                    let progress = Math.min(1, (control.millis() - startTime) / this.transitionDuration);\n\n                    progress = timingFunction(progress, this.transitionFunc);\n                    if (direction === CollisionDirection.Right) {\n                        const offset = Math.round(progress * screen.width);\n                        screen.scroll(screen.width - offset, 0);\n                        screen.drawImage(savedScreen, -offset, 0);\n                    }\n                    else if (direction === CollisionDirection.Left) {\n                        const offset = Math.round(progress * screen.width);\n                        screen.scroll(-(screen.width - offset), 0);\n                        screen.drawImage(savedScreen, offset, 0);\n                    }\n                    else if (direction === CollisionDirection.Top) {\n                        const offset = Math.round(progress * screen.height);\n                        screen.scroll(0, -(screen.height - offset));\n                        screen.drawImage(savedScreen, 0, offset);\n                    }\n                    else {\n                        const offset = Math.round(progress * screen.height);\n                        screen.scroll(0, screen.height - offset);\n                        screen.drawImage(savedScreen, 0, -offset);\n                    }\n\n                    if (!playerIsInvisible) {\n                        const playerDestinationLeft = this.playerSprite.left - game.currentScene().camera.drawOffsetX;\n                        const playerDestinationTop = this.playerSprite.top - game.currentScene().camera.drawOffsetY;\n\n                        const left = playerScreenLeft + (playerDestinationLeft - playerScreenLeft) * progress;\n                        const top = playerScreenTop + (playerDestinationTop - playerScreenTop) * progress;\n                        screen.drawTransparentImage(this.playerSprite.image, left, top);\n                    }\n                });\n\n                const previousScene = game.currentScene();\n                game.pushScene();\n\n                scene.createRenderable(1, () => {\n                    const currentMap = game.currentScene().tileMap;\n                    const currentCamera = game.currentScene().camera;\n\n                    // if any render functions in the user project try to get the tilemap,\n                    // they do so by getting it off of the current scene. override the scene's\n                    // tilemap so that they get the map they're expecting\n                    game.currentScene().tileMap = previousScene.tileMap;\n                    game.currentScene().camera = previousScene.camera;\n                    game.currentScene().camera.update();\n\n                    previousScene.render();\n\n                    game.currentScene().tileMap = currentMap;\n                    game.currentScene().camera = currentCamera;\n\n                    if (control.millis() - startTime >= this.transitionDuration) {\n                        this.isTransitioning = false;\n                        game.popScene();\n                        renderer.destroy();\n                        if (!playerIsInvisible) {\n                            this.playerSprite.setFlag(SpriteFlag.Invisible, false);\n                        }\n                    }\n                })\n            };\n\n            callback = game.eventContext().registerFrameHandler(-1, loadNewMap);\n        }\n\n        protected startColorTransition(newMap: tiles.TileMapData, r: number, g: number, b: number) {\n            this.isTransitioning = true;\n            const previousScene = game.currentScene();\n            game.pushScene();\n\n            const startTime = control.millis();\n\n            const originalPalette = hex`__palette`;\n\n            scene.createRenderable(1, () => {\n                let progress = Math.min(1, (control.millis() - startTime) / this.transitionDuration);\n                progress = timingFunction(progress, this.transitionFunc);\n\n                if (progress > 0.5) {\n                    game.popScene();\n                    tiles.setTilemap(newMap);\n                    if (this.playerSprite) {\n                        this.playerSprite.left = this.nextPlayerLeft;\n                        this.playerSprite.top = this.nextPlayerTop;\n                    }\n                    this.fireMapLoadEvent();\n\n                    game.pushScene();\n\n                    scene.createRenderable(1, () => {\n                        let progress = Math.min(1, (control.millis() - startTime) / this.transitionDuration);\n                        progress = timingFunction(progress, this.transitionFunc);\n\n                        image.setPalette(fadePaletteFromColor(\n                            originalPalette,\n                            r,\n                            g,\n                            b,\n                            (progress - 0.5) * 2\n                        ))\n                        previousScene.render();\n\n                        if (progress === 1) {\n                            game.popScene();\n                            this.isTransitioning = false;\n                        }\n                    })\n                }\n                else {\n                    image.setPalette(fadePaletteToColor(\n                        originalPalette,\n                        r,\n\n                        g,\n                        b,\n                        progress * 2\n                    ))\n                    previousScene.render();\n                }\n            })\n        }\n\n        protected fireMapLoadEvent() {\n            for (const handler of this.mapLoadedHandlers) {\n                handler(this.column, this.row, this.getMap(this.column, this.row));\n            }\n        }\n    }\n\n    function createState() {\n        return new State();\n    }\n\n    export function _state(): State {\n        return __util.getState(createState);\n    }\n\n    function canSpriteFit(\n        map: tiles.TileMapData,\n        left: number,\n        top: number,\n        width: number,\n        height: number\n    ) {\n        const x0 = left >> map.scale;\n        const y0 = top >> map.scale;\n        const x1 = (left + width - 1) >> map.scale;\n        const y1 = (top + height - 1) >> map.scale;\n\n        for (let x = x0; x <= x1; x++) {\n            for (let y = y0; y <= y1; y++) {\n                if (map.isWall(x, y)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function timingFunction(x: number, func: TimingFunction) {\n        // equations from https://easings.net/\n        switch (func) {\n            case TimingFunction.Linear:\n                return x;\n            case TimingFunction.EaseIn:\n                return x * x * x;\n            case TimingFunction.EaseOut:\n                return 1 - Math.pow(1 - x, 3);\n            case TimingFunction.EaseInOut:\n                return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;\n            case TimingFunction.EaseInExponential:\n                return x === 0 ? 0 : Math.pow(2, 10 * x - 10);\n            case TimingFunction.EaseOutExponential:\n                return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);\n            case TimingFunction.EaseInOutExponential:\n                return x === 0\n                    ? 0\n                    : x === 1\n                        ? 1\n                        : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2\n                            : (2 - Math.pow(2, -20 * x + 10)) / 2;\n        }\n    }\n\n    function fadePaletteToColor(palette: Buffer, r: number, g: number, b: number, progress: number) {\n        const result = palette.slice();\n        for (let i = 0; i < palette.length; i += 3) {\n            result[i] += (r - palette[i]) * progress;\n            result[i + 1] += (g - palette[i + 1]) * progress;\n            result[i + 2] += (b - palette[i + 2]) * progress;\n        }\n        return result;\n    }\n\n    function fadePaletteFromColor(palette: Buffer, r: number, g: number, b: number, progress: number) {\n        const result = palette.slice();\n        for (let i = 0; i < palette.length; i += 3) {\n            result[i] = r + (palette[i] - r) * progress;\n            result[i + 1] = g + (palette[i + 1] - g) * progress;\n            result[i + 2] = b + (palette[i + 2] - b) * progress;\n        }\n        return result;\n    }\n\n    function parseColor(color: string) {\n        let r = 0;\n        let g = 0;\n        let b = 0;\n\n        if (color.length === 3) {\n            r = parseInt(color.charAt(0), 16);\n            g = parseInt(color.charAt(1), 16);\n            b = parseInt(color.charAt(2), 16);\n        }\n        else if (color.length === 4) {\n            r = parseInt(color.charAt(1), 16);\n            g = parseInt(color.charAt(2), 16);\n            b = parseInt(color.charAt(3), 16);\n        }\n        else if (color.length === 6) {\n            r = parseInt(color.slice(0, 2), 16);\n            g = parseInt(color.slice(2, 4), 16);\n            b = parseInt(color.slice(4), 16);\n        }\n        else if (color.length === 7) {\n            r = parseInt(color.slice(1, 3), 16);\n            g = parseInt(color.slice(3, 5), 16);\n            b = parseInt(color.slice(5), 16);\n        }\n        else if (color.length === 8) {\n            r = parseInt(color.slice(2, 4), 16);\n            g = parseInt(color.slice(4, 6), 16);\n            b = parseInt(color.slice(6), 16);\n        }\n\n        const colorNum = (r << 16) | (g << 8) | b;\n\n        if (Number.isNaN(colorNum)) {\n            return 0;\n        }\n\n        return colorNum;\n    }\n\n    function dumpImage(image: Image) {\n        let result = \"img`\\n\";\n        const hexChars = \"0123456789ABCDEF\";\n        for (let y = 0; y < image.height; y++) {\n            let row = \"    \";\n            for (let x = 0; x < image.width; x++) {\n                row += hexChars.charAt(image.getPixel(x, y));;\n                if (x < image.width - 1) {\n                    row += \" \";\n                }\n                else {\n                    row += \"\\n\";\n                }\n            }\n            result += row;\n        }\n        result += \"`\";\n        console.log(result);\n    }\n}","continuousTilemap.ts":"namespace overworld {\n    export class TileMapData extends tiles.TileMapData {\n        protected rows: number;\n        protected columns: number;\n        mapWidth: number;\n        mapHeight: number;\n        protected extendedTileset: Image[];\n        protected tileMapping: Buffer[][];\n\n        constructor(protected maps: tiles.TileMapData[][]) {\n            super(control.createBuffer(6), img`.`, [], getScale(maps));\n\n            this.mapWidth = 255;\n            this.mapHeight = 255;\n\n            this.rows = maps.length;\n            this.columns = 0;\n\n            this.extendedTileset = [];\n            this.tileMapping = [];\n\n            for (const row of maps) {\n                this.columns = Math.max(this.columns, row.length);\n                const rowMapping: Buffer[] = [];\n                this.tileMapping.push(rowMapping);\n\n                for (const map of row) {\n                    if (map) {\n                        this.mapWidth = Math.min(this.mapWidth, map.width);\n                        this.mapHeight = Math.min(this.mapHeight, map.height);\n                        const ts = map.getTileset();\n                        const mapping = control.createBuffer(ts.length)\n                        rowMapping.push(mapping);\n\n                        for (let j = 0; j < ts.length; j++) {\n                            const mapTile = ts[j];\n                            let foundIt = false;\n                            for (let i = 0; i < this.extendedTileset.length; i++) {\n                                const current = this.extendedTileset[i];\n\n                                if (current.equals(mapTile)) {\n                                    mapping[j] = i;\n                                    foundIt = true;\n                                    break;\n                                }\n                            }\n\n                            if (!foundIt) {\n                                mapping[j] = this.extendedTileset.length;\n                                this.extendedTileset.push(mapTile);\n                            }\n                        }\n                    }\n                    else {\n                        rowMapping.push(undefined);\n                    }\n                }\n            }\n        }\n\n        get width(): number {\n            return this.mapWidth * this.columns;\n        }\n\n        get height(): number {\n            return this.mapHeight * this.rows;\n        }\n\n        getTile(col: number, row: number) {\n            if (this.isOutsideMap(col, row)) return 0;\n\n            const map = this.getMap(col, row);\n            if (!map) return 0;\n\n            const overworldCol = Math.idiv(col, this.mapWidth);\n            const overworldRow = Math.idiv(row, this.mapHeight);\n\n            const tilesetMapping = this.tileMapping[overworldRow][overworldCol];\n            const data = map.getTile(col % this.mapWidth, row % this.mapHeight);\n\n            return tilesetMapping[data];\n        }\n\n        setTile(col: number, row: number, tile: number) {\n            if (this.isOutsideMap(col, row)) return;\n\n            const map = this.getMap(col, row);\n            if (!map) return;\n\n            const overworldCol = Math.idiv(col, this.mapWidth);\n            const overworldRow = Math.idiv(row, this.mapHeight);\n\n            const tilesetMapping = this.tileMapping[overworldRow][overworldCol];\n\n            for (let i = 0; i < tilesetMapping.length; i++) {\n                if (tilesetMapping[i] === tile) {\n                    map.setTile(col % this.mapWidth, row % this.mapHeight, i);\n                    return;\n                }\n            }\n\n            const newMapping = control.createBuffer(tilesetMapping.length + 1);\n            newMapping.write(0, tilesetMapping);\n            const newIndex = newMapping.length - 1;\n            newMapping[newIndex] = tile;\n\n            this.tileMapping[overworldRow][overworldCol] = newMapping;\n\n            map.setTile(col % this.mapWidth, row % this.mapHeight, newIndex);\n        }\n\n        getTileset() {\n            return this.extendedTileset;\n        }\n\n        getTileImage(index: number) {\n            const size = 1 << this.scale;\n            let cachedImage = this.cachedTileView[index];\n            if (!cachedImage) {\n                const originalImage = this.extendedTileset[index];\n\n                if (originalImage) {\n                    if (originalImage.width <= size && originalImage.height <= size) {\n                        cachedImage = originalImage;\n                    } else {\n                        cachedImage = image.create(size, size);\n                        cachedImage.drawImage(originalImage, 0, 0);\n                    }\n                    this.cachedTileView[index] = cachedImage;\n                }\n            }\n            return cachedImage;\n        }\n\n        setWall(col: number, row: number, on: boolean) {\n            const map = this.getMap(col, row);\n            if (!map) return;\n\n            map.setWall(col % this.mapWidth, row % this.mapHeight, on);\n        }\n\n        isWall(col: number, row: number) {\n            const map = this.getMap(col, row);\n            if (!map) return true;\n\n            return map.isWall(col % this.mapWidth, row % this.mapHeight);\n        }\n\n        protected getMap(col: number, row: number) {\n            const overworldCol = Math.idiv(col, this.mapWidth);\n            const overworldRow = Math.idiv(row, this.mapHeight);\n\n            const mapRow = this.maps[overworldRow];\n\n            if (mapRow) return mapRow[overworldCol];\n            return undefined;\n        }\n    }\n\n    function getScale(maps: tiles.TileMapData[][]) {\n        for (const row of maps) {\n            for (const map of row) {\n                if (map) {\n                    return map.scale;\n                }\n            }\n        }\n\n        return TileScale.Sixteen\n    }\n\n    export class TileMap extends tiles.TileMap {\n        constructor(scale: TileScale = TileScale.Sixteen) {\n            super(scale);\n        }\n\n        protected isInvalidIndex(index: number): boolean {\n            return index < 0 || index > 0xffff;\n        }\n\n        protected draw(target: Image, camera: scene.Camera) {\n            if (!this.enabled) return;\n\n            // render tile map\n            const bitmask = (0x1 << this.scale) - 1;\n            const offsetX = camera.drawOffsetX & bitmask;\n            const offsetY = camera.drawOffsetY & bitmask;\n\n            const x0 = Math.max(0, camera.drawOffsetX >> this.scale);\n            const xn = Math.min(this._map.width, ((camera.drawOffsetX + target.width) >> this.scale) + 1);\n            const y0 = Math.max(0, camera.drawOffsetY >> this.scale);\n            const yn = Math.min(this._map.height, ((camera.drawOffsetY + target.height) >> this.scale) + 1);\n\n            for (let x = x0; x <= xn; ++x) {\n                for (let y = y0; y <= yn; ++y) {\n                    const index = this._map.getTile(x, y);\n                    const tile = this._map.getTileImage(index);\n                    if (tile) {\n                        target.drawTransparentImage(\n                            tile,\n                            ((x - x0) << this.scale) - offsetX,\n                            ((y - y0) << this.scale) - offsetY\n                        );\n                    }\n                }\n            }\n\n            if (game.debug) {\n                // render debug grid overlay\n                for (let x = x0; x <= xn; ++x) {\n                    const xLine = ((x - x0) << this.scale) - offsetX;\n                    if (xLine >= 0 && xLine <= screen.width) {\n                        target.drawLine(\n                            xLine,\n                            0,\n                            xLine,\n                            target.height,\n                            1\n                        );\n                    }\n                }\n\n                for (let y = y0; y <= yn; ++y) {\n                    const yLine = ((y - y0) << this.scale) - offsetY;\n                    if (yLine >= 0 && yLine <= screen.height) {\n                        target.drawLine(\n                            0,\n                            yLine,\n                            target.width,\n                            yLine,\n                            1\n                        );\n                    }\n                }\n            }\n        }\n    }\n}","api.ts":"//% color=\"#19572b\"\n//% icon=\"\\uf0ac\"\nnamespace overworld {\n    export enum LocationProperty {\n        //% block=\"column\"\n        Column,\n        //% block=\"row\"\n        Row\n    }\n\n    export enum TimingFunction {\n        //% block=\"linear\"\n        Linear,\n        //% block=\"ease in cubic\"\n        EaseIn,\n        //% block=\"ease out cubic\"\n        EaseOut,\n        //% block=\"ease in out cubic\"\n        EaseInOut,\n        //% block=\"ease in exponential\"\n        EaseInExponential,\n        //% block=\"ease out exponential\"\n        EaseOutExponential,\n        //% block=\"ease in out exponential\"\n        EaseInOutExponential\n    }\n\n    export enum AnimationType {\n        //% block=\"none\"\n        None,\n        //% block=\"scroll\"\n        Scroll,\n        //% block=\"fade to white\"\n        FadeToWhite,\n        //% block=\"fade to black\"\n        FadeToBlack,\n        //% block=\"fade to custom color\"\n        FadeToColor\n    }\n\n    //% blockId=overworld_setOverworld16\n    //% block=\"set overworld $maps\"\n    //% maps.shadow=overworld_createMap16\n    //% group=Create\n    //% weight=100\n    //% help=github:arcade-overworld/docs/set-overworld\n    export function setOverworld16(maps: tiles.TileMapData[][]): void {\n        _state().setMap(maps);\n    }\n\n    //% blockId=overworld_setOverworld8\n    //% block=\"set overworld $maps\"\n    //% maps.shadow=overworld_createMap8\n    //% group=Create\n    //% weight=90\n    //% help=github:arcade-overworld/docs/set-overworld\n    export function setOverworld8(maps: tiles.TileMapData[][]): void {\n        _state().setMap(maps);\n    }\n\n    //% blockId=overworld_setPlayerSprite\n    //% block=\"set player sprite $sprite\"\n    //% sprite.shadow=variables_get\n    //% sprite.defl=mySprite\n    //% group=Create\n    //% weight=80\n    //% help=github:arcade-overworld/docs/set-player-sprite\n    export function setPlayerSprite(sprite: Sprite): void {\n        _state().setPlayerSprite(sprite);\n    }\n\n    //% blockId=overworld_currentLocation\n    //% block=\"overworld location $property\"\n    //% group=Load\n    //% weight=100\n    //% help=github:arcade-overworld/docs/current-location\n    export function currentLocation(property: LocationProperty): number {\n        return _state().currentLocation(property);\n    }\n\n    //% blockId=overworld_loadMap\n    //% block=\"load overworld map at col $column row $row\"\n    //% group=Load\n    //% weight=90\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/load-map\n    export function loadMap(column: number, row: number): void {\n        _state().loadMap(column, row);\n    }\n\n    //% blockId=overworld_loadMapInDirection\n    //% block=\"load overworld map in direction $direction\"\n    //% group=Load\n    //% weight=80\n    //% help=github:arcade-overworld/docs/load-map-in-direction\n    export function loadMapInDirection(direction: CollisionDirection): void {\n        const column = currentLocation(LocationProperty.Column);\n        const row = currentLocation(LocationProperty.Row);\n\n        if (direction === CollisionDirection.Top) {\n            loadMap(column, row - 1);\n        }\n        else if (direction === CollisionDirection.Right) {\n            loadMap(column + 1, row);\n        }\n        else if (direction === CollisionDirection.Bottom) {\n            loadMap(column, row + 1);\n        }\n        else {\n            loadMap(column - 1, row);\n        }\n    }\n\n    //% blockId=overworld_getMapAt\n    //% block=\"get overworld map at col $column row $row\"\n    //% group=Load\n    //% weight=70\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/get-map-at\n    export function getMapAt(column: number, row: number): tiles.TileMapData {\n        return _state().getMap(column, row);\n    }\n\n    //% blockId=overworld_getMapInDirection\n    //% block=\"get overworld map in direction $direction\"\n    //% group=Load\n    //% weight=60\n    //% help=github:arcade-overworld/docs/get-map-in-direction\n    export function getMapInDirection(direction: CollisionDirection): tiles.TileMapData {\n        const column = currentLocation(LocationProperty.Column);\n        const row = currentLocation(LocationProperty.Row);\n\n        if (direction === CollisionDirection.Top) {\n            return getMapAt(column, row - 1);\n        }\n        else if (direction === CollisionDirection.Right) {\n            return getMapAt(column + 1, row);\n        }\n        else if (direction === CollisionDirection.Bottom) {\n            return getMapAt(column, row + 1);\n        }\n        else {\n            return getMapAt(column - 1, row);\n        }\n    }\n\n    //% blockId=overworld_mapExistsAt\n    //% block=\"overworld map exists at col $column row $row\"\n    //% group=Load\n    //% weight=50\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/map-exists-at\n    export function mapExistsAt(column: number, row: number): boolean {\n        return !!getMapAt(column, row);\n    }\n\n    //% blockId=overworld_mapExistsInDirection\n    //% block=\"overworld map exists in direction $direction\"\n    //% group=Load\n    //% weight=40\n    //% help=github:arcade-overworld/docs/map-exists-in-direction\n    export function mapExistsInDirection(direction: CollisionDirection): boolean {\n        return !!getMapInDirection(direction);\n    }\n\n    //% blockId=overworld_onMapLoaded\n    //% block=\"on map loaded at $overworldColumn $overworldRow $map\"\n    //% draggableParameters=\"reporter\"\n    //% group=Load\n    //% weight=30\n    //% help=github:arcade-overworld/docs/on-map-loaded\n    export function onMapLoaded(handler: (overworldColumn: number, overworldRow: number, map: tiles.TileMapData) => void) {\n        _state().addMapLoadedListener(handler);\n    }\n\n    //% blockId=overworld_setAnimationType\n    //% block=\"overworld set animation type $animationType\"\n    //% group=Animation\n    //% weight=100\n    //% help=github:arcade-overworld/docs/set-animation-type\n    export function setAnimationType(animationType: AnimationType) {\n        _state().transitionType = animationType;\n    }\n\n    //% blockId=overworld_setAnimationDuration\n    //% block=\"overworld set animation duration $duration\"\n    //% duration.shadow=timePicker\n    //% group=Animation\n    //% weight=90\n    //% help=github:arcade-overworld/docs/set-animation-duration\n    export function setAnimationDuration(duration: number) {\n        _state().transitionDuration = duration;\n    }\n\n    //% blockId=overworld_setAnimationTimingFunction\n    //% block=\"overworld set animation timing function $func\"\n    //% group=Animation\n    //% weight=80\n    //% help=github:arcade-overworld/docs/set-animation-timing-function\n    export function setAnimationTimingFunction(func: TimingFunction) {\n        _state().transitionFunc = func;\n    }\n\n    //% blockId=overworld_setAnimationFadeColor\n    //% block=\"overworld set animation custom fade color $color\"\n    //% group=Animation\n    //% color.defl=\"#000000\"\n    //% weight=70\n    //% help=github:arcade-overworld/docs/set-animation-fade-color\n    export function setAnimationFadeColor(color: string) {\n        _state().setFadeColor(color);\n    }\n\n    //% blockId=overworld_setScrollAnimationZIndex\n    //% block=\"overworld set scroll animation z $z\"\n    //% group=Animation\n    //% z.defl=99\n    //% weight=70\n    //% help=github:arcade-overworld/docs/set-scroll-animation-z-index\n    export function setScrollAnimationZIndex(z: number) {\n        _state().setScrollAnimationZIndex(z);\n    }\n\n    //% blockId=overworld_setMapTransitionsEnabled\n    //% block=\"set overworld transitions enabled $enabled\"\n    //% group=Options\n    //% weight=100\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/set-map-transitions-enabled\n    export function setMapTransitionsEnabled(enabled: boolean) {\n        _state().setMapTransitionsEnabled(enabled);\n    }\n\n    //% blockId=overworld_setMapTransitionRadius\n    //% block=\"set overworld transition radius $radius\"\n    //% group=Options\n    //% weight=90\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/set-map-transition-radius\n    export function setMapTransitionRadius(radius: number) {\n        _state().setMapTransitionRadius(radius);\n    }\n\n    //% blockId=overworld_setWallsBlockTransitions\n    //% block=\"set walls block map transitions $blockEnabled\"\n    //% group=Options\n    //% weight=80\n    //% help=github:arcade-overworld/docs/set-walls-block-transitions\n    export function setWallsBlockTransitions(blockEnabled: boolean) {\n        _state().setWallsBlockTransitions(blockEnabled);\n    }\n\n    //% blockId=overworld_setContinuousModeEnabled\n    //% block=\"set continuous mode enabled $enabled\"\n    //% group=Options\n    //% weight=70\n    //% help=github:arcade-overworld/docs/set-continuous-mode-enabled\n    export function setContinuousModeEnabled(enabled: boolean) {\n        _state().setContinuousModeEnabled(enabled);\n    }\n\n    //% blockId=overworld_createMap16\n    //% block=\"$row0 $row1 $row2|| $row3 $row4 $row5\"\n    //% row0.shadow=overworld_mapRow16\n    //% row1.shadow=overworld_mapRow16\n    //% row2.shadow=overworld_mapRow16\n    //% row3.shadow=overworld_mapRow16\n    //% row4.shadow=overworld_mapRow16\n    //% row5.shadow=overworld_mapRow16\n    //% inlineInputMode=external\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function createMap16(\n        row0: tiles.TileMapData[],\n        row1: tiles.TileMapData[],\n        row2: tiles.TileMapData[],\n        row3?: tiles.TileMapData[],\n        row4?: tiles.TileMapData[],\n        row5?: tiles.TileMapData[],\n    ): tiles.TileMapData[][] {\n        return createMap(\n            row0,\n            row1,\n            row2,\n            row3,\n            row4,\n            row5\n        );\n    }\n\n    //% blockId=overworld_createMap8\n    //% block=\"$row0 $row1 $row2|| $row3 $row4 $row5\"\n    //% row0.shadow=overworld_mapRow8\n    //% row1.shadow=overworld_mapRow8\n    //% row2.shadow=overworld_mapRow8\n    //% row3.shadow=overworld_mapRow8\n    //% row4.shadow=overworld_mapRow8\n    //% row5.shadow=overworld_mapRow8\n    //% inlineInputMode=external\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function createMap8(\n        row0: tiles.TileMapData[],\n        row1: tiles.TileMapData[],\n        row2: tiles.TileMapData[],\n        row3?: tiles.TileMapData[],\n        row4?: tiles.TileMapData[],\n        row5?: tiles.TileMapData[],\n    ): tiles.TileMapData[][] {\n        return createMap(\n            row0,\n            row1,\n            row2,\n            row3,\n            row4,\n            row5\n        );\n    }\n\n    //% blockId=overworld_mapRow16\n    //% block=\"$map0 $map1 $map2|| $map3 $map4 $map5\"\n    //% map0.shadow=overworld_tilemap16\n    //% map1.shadow=overworld_tilemap16\n    //% map2.shadow=overworld_tilemap16\n    //% map3.shadow=overworld_tilemap16\n    //% map4.shadow=overworld_tilemap16\n    //% map5.shadow=overworld_tilemap16\n    //% inlineInputMode=inline\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function mapRow16(\n        map0: tiles.TileMapData,\n        map1: tiles.TileMapData,\n        map2: tiles.TileMapData,\n        map3?: tiles.TileMapData,\n        map4?: tiles.TileMapData,\n        map5?: tiles.TileMapData,\n    ): tiles.TileMapData[] {\n        return createMapRow(\n            map0,\n            map1,\n            map2,\n            map3,\n            map4,\n            map5,\n        );\n    }\n\n    //% blockId=overworld_mapRow8\n    //% block=\"$map0 $map1 $map2|| $map3 $map4 $map5\"\n    //% map0.shadow=overworld_tilemap8\n    //% map1.shadow=overworld_tilemap8\n    //% map2.shadow=overworld_tilemap8\n    //% map3.shadow=overworld_tilemap8\n    //% map4.shadow=overworld_tilemap8\n    //% map5.shadow=overworld_tilemap8\n    //% inlineInputMode=inline\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function mapRow8(\n        map0: tiles.TileMapData,\n        map1: tiles.TileMapData,\n        map2: tiles.TileMapData,\n        map3?: tiles.TileMapData,\n        map4?: tiles.TileMapData,\n        map5?: tiles.TileMapData,\n    ): tiles.TileMapData[] {\n        return createMapRow(\n            map0,\n            map1,\n            map2,\n            map3,\n            map4,\n            map5,\n        );\n    }\n\n    function createMapRow(\n        map0: tiles.TileMapData,\n        map1: tiles.TileMapData,\n        map2: tiles.TileMapData,\n        map3?: tiles.TileMapData,\n        map4?: tiles.TileMapData,\n        map5?: tiles.TileMapData,\n        map6?: tiles.TileMapData,\n        map7?: tiles.TileMapData,\n        map8?: tiles.TileMapData,\n        map9?: tiles.TileMapData,\n        map10?: tiles.TileMapData,\n        map11?: tiles.TileMapData,\n    ): tiles.TileMapData[] {\n        const res = [\n            map0,\n            map1,\n            map2,\n            map3,\n            map4,\n            map5,\n            map6,\n            map7,\n            map8,\n            map9,\n            map10,\n            map11\n        ];\n\n        return res.filter(m => !!m);\n    }\n\n    function createMap(\n        row0: tiles.TileMapData[],\n        row1: tiles.TileMapData[],\n        row2: tiles.TileMapData[],\n        row3?: tiles.TileMapData[],\n        row4?: tiles.TileMapData[],\n        row5?: tiles.TileMapData[],\n        row6?: tiles.TileMapData[],\n        row7?: tiles.TileMapData[],\n        row8?: tiles.TileMapData[],\n        row9?: tiles.TileMapData[],\n        row10?: tiles.TileMapData[],\n        row11?: tiles.TileMapData[],\n    ): tiles.TileMapData[][] {\n        const res = [\n            row0,\n            row1,\n            row2,\n            row3,\n            row4,\n            row5,\n            row6,\n            row7,\n            row8,\n            row9,\n            row10,\n            row11\n        ];\n\n        return res.filter(m => !!m && m.length > 0);\n    }\n\n    //% blockId=overworld_tilemap8\n    //% block=\"8 $tilemap\"\n    //% tilemap.fieldEditor=\"tilemap\"\n    //% tilemap.fieldOptions.decompileArgumentAsString=\"true\"\n    //% tilemap.fieldOptions.filter=\"tile\"\n    //% tilemap.fieldOptions.taggedTemplate=\"tilemap\"\n    //% tilemap.fieldOptions.tileWidth=8\n    //% tilemap.fieldOptions.initWidth=20\n    //% tilemap.fieldOptions.initHeight=15\n    //% group=\"Tilemaps\" weight=49 blockGap=8\n    //% duplicateShadowOnDrag\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function tilemap8(tilemap: tiles.TileMapData): tiles.TileMapData {\n        return tilemap;\n    }\n\n    //% blockId=overworld_tilemap16\n    //% block=\"16 $tilemap\"\n    //% tilemap.fieldEditor=\"tilemap\"\n    //% tilemap.fieldOptions.decompileArgumentAsString=\"true\"\n    //% tilemap.fieldOptions.filter=\"tile\"\n    //% tilemap.fieldOptions.taggedTemplate=\"tilemap\"\n    //% tilemap.fieldOptions.tileWidth=16\n    //% tilemap.fieldOptions.initWidth=10\n    //% tilemap.fieldOptions.initHeight=8\n    //% group=\"Tilemaps\" weight=49 blockGap=8\n    //% duplicateShadowOnDrag\n    //% group=Shadows\n    //% blockGap=8\n    //% help=github:arcade-overworld/docs/create-map\n    export function tilemap16(tilemap: tiles.TileMapData): tiles.TileMapData {\n        return tilemap;\n    }\n}","README.md":"# arcade-overworld\n\nA MakeCode Arcade extension for connecting multiple tilemaps in a grid. For example, you could use this extension to make a dungeon crawling game with multiple rooms. Overworld makes it super easy to transition between tilemaps, all you need to do is set which sprite should act as the player sprite and the extension will handle the rest!\n\n>As of February 2025, there is a known bug where the overworld blocks in the toolbox don't populate their arguments correctly. As a result, you need to drag the shadow blocks from the \"Shadows\" section of the toolbox to fill in the rows for the overworld tilemap. This will be fixed in the next version of Arcade\n\n[Here's a basic example](https://makecode.com/_7bc4wCTCVWby)\n\n![A screenshot of the blocks code from the above share link.](./media/basic-example.png)\n\n\n## The overworld grid\n\nThe grid in the overworld is created using the set overworld block. Once an overworld is set, you can reference maps in the grid using coordinates like so:\n\n![A screenshot of the \"set overworld\" block with a 3 by 3 coordinate grid overlaid on top of it. The horizontal axis of the grid is labelled \"Columns\", and increases in the rightward direction. The vertical axis of the grid is labelled \"Rows\", and increases in the downward direction.](./media/coordinates.png)\n\nIn the above example, the top-left tilemap is at the coordinate `column=0 row=0`. The bottom-right tilemap is at the coordinate `column=2 row=2`.\n\n## Transitioning between maps\n\nThe overworld extension will automatically load the next map whenever the player sprite approaches the edge of the current map. You can control how far away from the edge the player needs to be for the transition to start by using the \"set transition radius\" block.\n\nBy default, overworld will try and find the closest non-wall tile in the map being loaded and place the player sprite there. For example, let's say we had a situation like this:\n\n![A diagram with two tilemaps next to each other. The left tilemap has a duck Sprite in it with an arrow pointing towards the right tilemap where a wall blocks the duck's path](./media/transition-diagram.png)\n\nWhen the duck sprite moves to the tilemap on the right, it will be placed in the first column available after the wall like so:\n\n![A diagram with two tilemaps next to each other. The duck has moved out of the left tilemap into the right tilemap where it is now in the second column, past the walls](./media/transition-diagram2.png)\n\nIf tilemaps in the overworld are different sizes, the sprite will still be moved to the closest unoccupied place. For example:\n\n![A diagram with two tilemaps next to each other. The left tilemap is taller than the right tilemap and has a duck sprite in it with an arrow pointing below the right tilemap. The right tilemap has a duck in the bottom left indicating where the duck will end up after moving.](./media/transition-diagram5.png)\n\nIn the above example, the duck is bumped up to the bottom of the destination tilemap. Note how the tilemaps are treated as if they are aligned on the top. For vertical transitions, tilemaps are aligned on the left.\n\n### Block map transitions with walls\n\nAlternatively, you can use the \"set walls block map transitions\" block to make it so that the player is blocked from moving to the map if there is a wall blocking the way in the destination map. If the player sprite is larger than one tile, the sprite will only be allowed to transition between maps if it can completely fit in the corresponding location between maps.\n\nFor example:\n\n![A diagram with two tilemaps next to each other. The left tilemap has two duck Sprites in it. The top duck has an arrow pointing towards a wall in the right tilemap with a large red X next to it. The bottom duck has an arrow pointing towards a gap in the wall in the right tilemap with a large green check next to it.](./media/transition-diagram3.png)\n\nIn the above diagram, the top duck would be blocked from moving between tilemaps because there is a wall in the destination tilemap that blocks its path. The lower duck is not blocked, so the tilemaps will transition as normal.\n\nIf one of the maps is larger than the other, the player sprite will also be blocked from moving to the next tilemap if it is outside the bounds of the destination map:\n\n![A diagram with two tilemaps next to each other. The left tilemap is taller than the right tilemap and has two duck Sprites in it. The top duck has an arrow pointing towards the right tilemap with a large green check next to it. The bottom duck has an arrow pointing towards an area below the right tilemap with a large red X next to it.](./media/transition-diagram4.png)\n\n## Animating tilemap transitions\n\nOverworld supports a few different ways of animating the transition between tilemaps. By default, there is no animation and tilemap transitions happen instantly.\n\nYour game is temporarily frozen while an animation plays. As a result all animating sprites will appear frozen until the animation completes. Be careful when using the pause block in your code if you have animations enabled; if a pause ends while the game is still frozen, it might lead to bugs!\n\n### Scroll\n\nThe scroll animation causes the camera to pan between the two tilemaps when transitioning. It's great for mimicking that old NES and SNES style of map transitions!\n\n![A looping GIF showing a cat sprite moving to the right in a dungeon-like tilemap. When the cat reaches the edge of the map, the tilemap scrolls to the left revealing another tilemap where the dungeon opens up into a grassy field. The cat then moves back to the first tilemap and the tilemap scrolls back.](./media/scroll-animation.gif)\n\n### Fade to white/black/custom\n\nThe various fade animations will cause the screen to fade to a color before loading the next map.\n\n![A looping GIF showing a cat sprite moving to the right in a dungeon-like tilemap. When the cat reaches the edge of the map, the screen fades to white and then back the original palette revealing another tilemap where the dungeon opens up into a grassy field. The cat then moves back to the first tilemap and the fade animation plays again.](./media/fade-animation.gif)\n\nWhen playing these animations, the overworld extension will always use whatever palette is set in the project settings. As a result, these animations are *not* compatible with the color-fading extension.\n\n### Timing functions\n\nYou can set the timing function for animations to control how the animation plays out. Try experimenting with all of the functions in the dropdown and see what they do! Setting the animation duration to longer will make it easier to tell what each one does.\n\n## Continuous mode\n\nIn addition to transitioning between discrete tilemaps, you can also put the overworld into \"continuous mode\" which will cause all of your tilemaps to be stitched together into one giant tilemap.\n\n[Continuous mode example](https://makecode.com/_LdDLux0vqRqz).\n\n> Note: to use continuous mode, all tilemaps in the overworld need to have the exact same width and height! They also need to use the same tile size; no mixing 16x16 and 8x8 tiles!\n\nContinuous mode can be useful if you want to make tilemaps that are larger than the maximum tilemap dimensions. You can also use this to bypass the limit of 255 tiles per tilemap, but that might cause some bugs so I wouldn't recommend it!\n\nYou might also use continuous mode if you want to reuse tilemaps inside of a bigger map. For example, if you were procedurally generating a dungeon you might want to use the same map for all of your hallways between rooms.\n\nWhen using continuous mode, the animation and transition blocks are disabled since there is no switching between tilemaps. However, you can still use the \"on map loaded\" event to figure out when the player moves between tilemaps. Likewise, the \"overworld location\" block will still return the column/row of the current sprite.\n\n## Procedurally generating dungeons\n\nThe overworld extension is great for procedurally generating dungeons! The argument being passed to the \"set overworld\" block is actually just a double array of tilemaps, so you can create your own randomly generated tilemap using arrays. Each index in the outer array represents a row in the overworld and each index in the inner arrays represents a column.\n\nI'll try to add a procedurally generated sample program to this README soon!","test.tilemap.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"level3\": {\n        \"id\": \"level3\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level3\"\n    },\n    \"level5\": {\n        \"id\": \"level5\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level5\"\n    },\n    \"level7\": {\n        \"id\": \"level7\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level7\"\n    },\n    \"level8\": {\n        \"id\": \"level8\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level8\"\n    },\n    \"level9\": {\n        \"id\": \"level9\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level9\"\n    },\n    \"level10\": {\n        \"id\": \"level10\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level10\"\n    },\n    \"level11\": {\n        \"id\": \"level11\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level11\"\n    },\n    \"level12\": {\n        \"id\": \"level12\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level12\"\n    },\n    \"level13\": {\n        \"id\": \"level13\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level13\"\n    },\n    \"level14\": {\n        \"id\": \"level14\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level14\"\n    },\n    \"level15\": {\n        \"id\": \"level15\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level15\"\n    },\n    \"level16\": {\n        \"id\": \"level16\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level16\"\n    },\n    \"level17\": {\n        \"id\": \"level17\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level17\"\n    },\n    \"level18\": {\n        \"id\": \"level18\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level18\"\n    },\n    \"level19\": {\n        \"id\": \"level19\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level19\"\n    },\n    \"level20\": {\n        \"id\": \"level20\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level20\"\n    },\n    \"level21\": {\n        \"id\": \"level21\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level21\"\n    },\n    \"level22\": {\n        \"id\": \"level22\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level22\"\n    },\n    \"level23\": {\n        \"id\": \"level23\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level23\"\n    },\n    \"level24\": {\n        \"id\": \"level24\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level24\"\n    },\n    \"level2\": {\n        \"id\": \"level2\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileGrass2\"\n        ],\n        \"displayName\": \"level2\"\n    },\n    \"level4\": {\n        \"id\": \"level4\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tilePath5\"\n        ],\n        \"displayName\": \"level4\"\n    },\n    \"level6\": {\n        \"id\": \"level6\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tileDarkGrass2\"\n        ],\n        \"displayName\": \"level6\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","test.tilemap.ts":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tilemap\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"level1\":\n            case \"level1\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level3\":\n            case \"level3\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level5\":\n            case \"level5\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level7\":\n            case \"level7\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level8\":\n            case \"level8\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level9\":\n            case \"level9\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level10\":\n            case \"level10\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level11\":\n            case \"level11\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level12\":\n            case \"level12\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level13\":\n            case \"level13\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level14\":\n            case \"level14\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level15\":\n            case \"level15\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level16\":\n            case \"level16\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level17\":\n            case \"level17\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level18\":\n            case \"level18\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level19\":\n            case \"level19\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level20\":\n            case \"level20\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level21\":\n            case \"level21\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level22\":\n            case \"level22\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level23\":\n            case \"level23\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level24\":\n            case \"level24\":return tiles.createTilemap(hex`0a0008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n`, [myTiles.transparency16], TileScale.Sixteen);\n            case \"level2\":\n            case \"level2\":return tiles.createTilemap(hex`1000100001010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101`, img`\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n`, [myTiles.transparency16,sprites.castle.tileGrass2], TileScale.Sixteen);\n            case \"level4\":\n            case \"level4\":return tiles.createTilemap(hex`1000100001010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101`, img`\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n`, [myTiles.transparency16,sprites.castle.tilePath5], TileScale.Sixteen);\n            case \"level6\":\n            case \"level6\":return tiles.createTilemap(hex`1000100001010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101`, img`\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n. . . . . . . . . . . . . . . .\n`, [myTiles.transparency16,sprites.castle.tileDarkGrass2], TileScale.Sixteen);\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n","test.ts":"overworld.setOverworld16(overworld.createMap16(\noverworld.mapRow16(overworld.tilemap16(tilemap`level2`), overworld.tilemap16(tilemap`level4`), overworld.tilemap16(tilemap`level6`)),\noverworld.mapRow16(overworld.tilemap16(tilemap`level2`), overworld.tilemap16(tilemap`level4`), overworld.tilemap16(tilemap`level6`)),\noverworld.mapRow16(overworld.tilemap16(tilemap`level2`), overworld.tilemap16(tilemap`level4`), overworld.tilemap16(tilemap`level6`))\n))\nlet mySprite = sprites.create(img`\n    . . . . . . . . . . b 5 b . . .\n    . . . . . . . . . b 5 b . . . .\n    . . . . . . b b b b b b . . . .\n    . . . . . b b 5 5 5 5 5 b . . .\n    . . . . b b 5 d 1 f 5 5 d f . .\n    . . . . b 5 5 1 f f 5 d 4 c . .\n    . . . . b 5 5 d f b d d 4 4 . .\n    . b b b d 5 5 5 5 5 4 4 4 4 4 b\n    b d d d b b d 5 5 4 4 4 4 4 b .\n    b b d 5 5 5 b 5 5 5 5 5 5 b . .\n    c d c 5 5 5 5 d 5 5 5 5 5 5 b .\n    c b d c d 5 5 b 5 5 5 5 5 5 b .\n    . c d d c c b d 5 5 5 5 5 d b .\n    . . c b d d d d d 5 5 5 b b . .\n    . . . c c c c c c c c b b . . .\n    . . . . . . . . . . . . . . . .\n    `, SpriteKind.Player)\ncontroller.moveSprite(mySprite)\noverworld.setPlayerSprite(mySprite)\nscene.cameraFollowSprite(mySprite)\noverworld.loadMap(0, 0)\nlet mySprite2 = sprites.create(img`\n    . . 2 2 b b b b b . . . . . . .\n    . 2 b 4 4 4 4 4 4 b . . . . . .\n    2 2 4 4 4 4 d d 4 4 b . . . . .\n    2 b 4 4 4 4 4 4 d 4 b . . . . .\n    2 b 4 4 4 4 4 4 4 d 4 b . . . .\n    2 b 4 4 4 4 4 4 4 4 4 b . . . .\n    2 b 4 4 4 4 4 4 4 4 4 e . . . .\n    2 2 b 4 4 4 4 4 4 4 b e . . . .\n    . 2 b b b 4 4 4 b b b e . . . .\n    . . e b b b b b b b e e . . . .\n    . . . e e b 4 4 b e e e b . . .\n    . . . . . e e e e e e b d b b .\n    . . . . . . . . . . . b 1 1 1 b\n    . . . . . . . . . . . c 1 d d b\n    . . . . . . . . . . . c 1 b c .\n    . . . . . . . . . . . . c c . .\n    `, SpriteKind.Player)\nmySprite2.z = 200\noverworld.setAnimationType(overworld.AnimationType.Scroll)\n"}}